#DATE:13/08/2022
#Assignment No:01
                       #Introduction To Python
Python is a general purpose, dynamic, high-level, and interpreted programming language. It supports Object Oriented programming approach to develop applications. It is simple and easy to learn and provides lots of high-level data structures.
Python is easy to learn yet powerful and versatile scripting language, which makes it attractive for Application Development.
Python's syntax and dynamic typing with its interpreted nature make it an ideal language for scripting and rapid application development.
 
# Why We Learn Python?
Python provides many useful features to the programmer. These features make it most popular and widely used language. We have listed below few-essential feature of Python.
o	Easy to use and Learn
o	Expressive Language
o	Interpreted Language
o	Object-Oriented Language
o	Open Source Language
o	Extensible
o	Learn Standard Library
o	GUI Programming Support
o	Integrated
o	Embeddable
o	Dynamic Memory Allocation
o	Wide Range of Libraries and Frameworks

#Where Is Python Used:
Python is a general-purpose, popular programming language and it is used in almost every technical field. The various areas of Python use are given below.
o	Data Science
o	Date Mining
o	Desktop Applications
o	Console-based Applications
o	Mobile Applications
o	Software Development
o	Artificial Intelligence
o	Web Applications
o	Enterprise Applications
o	3D CAD Applications
o	Machine Learning
o	Computer Vision or Image Processing Applications.
o	Speech Recognitions
 
#Python Popular Frameworks And Libraries
Python has wide range of libraries and frameworks widely used in various fields such as machine learning, artificial intelligence, web applications, etc. We define some popular frameworks and libraries of Python as follows.
o	Web development (Server-side) - Django Flask, Pyramid, CherryPy
o	GUIs based applications - Tk, PyGTK, PyQt, PyJs, etc.
o	Machine Learning - TensorFlow, PyTorch, Scikit-learn, Matplotlib, Scipy, etc.
o	Mathematics - Numpy, Pandas, etc

#Python Variables
Variable is a name that is used to refer to memory location. Python variable is also known as an identifier and used to hold value.
In Python, we don't need to specify the type of variable because Python is a infer language and smart enough to get variable type.
Variable names can be a group of both the letters and digits, but they have to begin with a letter or an underscore.
It is recommended to use lowercase letters for the variable name. Rahul and rahul both are two different variables.

#Identifier Naming
Variables are the example of identifiers. An Identifier is used to identify the literals used in the program. The rules to name an identifier are given below.
o	The first character of the variable must be an alphabet or underscore ( _ ).
o	All the characters except the first character may be an alphabet of lower-case(a-z), upper-case (A-Z), underscore, or digit (0-9).
o	Identifier name must not contain any white-space, or special character (!, @, #, %, ^, &, *).
o	Identifier name must not be similar to any keyword defined in the language.
o	Identifier names are case sensitive; for example, my name, and MyName is not the same.
o	Examples of valid identifiers: a123, _n, n_9, etc.
o	Examples of invalid identifiers: 1a, n%4, n 9, etc

#Declaring Variable and Assigning Values
Python does not bind us to declare a variable before using it in the application. It allows us to create a variable at the required time.
We don't need to declare explicitly variable in Python. When we assign any value to the variable, that variable is declared automatically.
The equal (=) operator is used to assign value to a variable.

#Data Types
Variables can hold values, and every value has a data-type. Python is a dynamically typed language; hence we do not need to define the type of the variable while declaring it. The interpreter implicitly binds the value with its type.
a = 10
The variable a holds integer value ten and we did not define its type. Python interpreter will automatically interpret variables a as an integer type.
Python enables us to check the type of the variable used in the program. Python provides us the type() function, which returns the type of the variable passed.

Consider the following example to define the values of different data types and checking its type.
a=20
b=”python”
c=”30.5
print(type(a))
print(type(b))
print(type(c))
Output:
<type 'int'>
<type 'str'>
<type 'float'>

#Python Literals
Python Literals can be defined as data that is given in a variable or constant.
Python supports the following literals:

1.String:String literals can be formed by enclosing a text in the quotes. We can use both single as well as double quotes to create a string.
Example:
"Aman" , '12345'  

2.Boolean:A Boolean literal can have any of the two values: True or False.
Example - Boolean Literals
x = (1 == True)  
y = (2 == False) 
Output:
x is True
y is False

3.Integer: It Is Used To Store The Neumeric Values.
Example:
A=5
B=10

4.Float: It is used to store the floating point values.
Example:
A=10.67
B=34.89

#Collection Literals:
Python provides the four types of literal collection such as List literals, Tuple literals, Dict literals, and Set literals.
List:

o	List contains items of different data types. Lists are mutable i.e., modifiable.
o	The values stored in List are separated by comma(,) and enclosed within square brackets([]). We can store different types of data in a List.
Example - List literals
list=['John',678,20.4,'Peter']    
list1=[456,'Andrew']    
print(list)    
print(list + list1)

#List Indexing And Slicing
The indexing is processed in the same way as it happens with the strings. The elements of the list can be accessed by using the slice operator [].
The index starts from 0 and goes to length - 1. The first element of the list is stored at the 0th index, the second element of the list is stored at the 1st index, and so on.
 
#We can get the sub-list of the list using the following syntax.

1.	list_varible(start:stop:step)  
o	The start denotes the starting index position of the list.
o	The stop denotes the last index position of the list.
o	The step is used to skip the nth element within a start:stop
Consider the following example:
1.	list = [1,2,3,4,5,6,7]  
2.	print(list[0])  
3.	print(list[1])  
4.	print(list[2])  
5.	print(list[3])  
6.	# Slicing the elements 
7.	print(list[0:6])  
8.	# By default the index value is 0 so its starts from the 0th element and go for index -1.  
9.	print(list[:])  
10.	print(list[2:5])  
11.	print(list[1:6:2])  
Output:
1
2
3
4
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[3, 4, 5]
[2, 4, 6]

#Unlike other languages, Python provides the flexibility to use the negative indexing also. The negative indices are counted from the right. The last element (rightmost) of the list has the index -1; its adjacent left element is present at the index -2 and so on until the left-most elements are encountered.
 
Let's have a look at the following example where we will use negative indexing to access the elements of the list.
1.	list = [1,2,3,4,5]  
2.	print(list[-1])  
3.	print(list[-3:])  
4.	print(list[:-1])  
5.	print(list[-3:-1])  
Output:
5
[3, 4, 5]
[1, 2, 3, 4]
[3, 4]
As we discussed above, we can get an element by using negative indexing. In the above code, the first print statement returned the rightmost element of the list. The second print statement returned the sub-list, and so on.

#DATE:16/08/2022
#ASSIGNMENT NO:02
#TOPIC : DIFFERENT OPERATION’S COLLECTION  DATA TYPES
#List Operations:

1.Concatinating using +

ls1=[1,2,3] 
ls2=[4,5,6]
print(ls1+ls2)

OUTPUT:
[1, 2, 3, 4, 5, 6]
2.Repeating using *

ls1=['j','a','v','a']
print(ls1*3)

OUTPUT:
['j', 'a', 'v', 'a', 'j', 'a', 'v', 'a', 'j', 'a', 'v', 'a']

3.List Slicing

 Extracting full list without using any index

ls1=['a','b','c','d','e']
print(ls1[:])

OUTPUT:
['a', 'b', 'c', 'd', 'e']

Selecting some middle elements

ls1=['p','y','t','h','o','n']
print(ls1[2:5])

OUTPUT:
[1, 2, 3, 4]
Using Negative Indexing

ls1=[1,2,3,4,5,6]
print(ls1[:-2])

OUTPUT:
[1, 2, 3, 4]

List Modifying

ls1=['a','b','c','d','e']
ls1[1:3]=['p','q']
print(ls1)

OUTPUT:
['a', 'p', 'q', 'd', 'e']

append():

ls1=['p','y','t','h','o','n']
ls1.append('list')
print(ls1)

OUTPUT:
['p', 'y', 't', 'h', 'o', 'n', 'list']

#extend():

ls1=[1,2,3,4]
ls2=[5,6]
ls2.extend(ls1)
ls1.extend(ls2)
print(ls1)
print(ls2)

OUTPUT:
[1, 2, 3, 4, 5, 6, 1, 2, 3, 4]
[5, 6, 1, 2, 3, 4]




Sort

ls1=[88,67,45,78,17]
ls1.sort()
print(ls1)

OUTPUT:

[17, 45, 67, 78, 88]
Reverse:

ls1=['j','a','v','a']
ls1.reverse()
print(ls1)
OUTPUT:

['a', 'v', 'a', 'j']

Count()
ls1=[1,2,4,6,2,8,9]
ls1.count(2)

OUTPUT:
2
Clear()

ls=[1,2,3]
ls.clear()
print(ls)

OUTPUT:
[]
Insert():

ls=[1,2,3,4]
ls.insert(1,"hi")
print(ls)
 
OUTPUT:
[1, 'hi', 2, 3, 4]
Index();

ls=[1,2,3,4,5,6,7,8,9]
ls.index(2)

OUTPUT:
1

Deleting An Elements
Using pop()

ls=[1,2,3,-4]
x=ls.pop()
print(ls)
print(x)

OUTPUT:
[2, 3, -4]
1

Remove(): 
ls=[5,8,-9,-3]
ls.remove(-9)
print(ls)

OUTPUT:

[5, 8, -3]

Del():
ls=[1,2,6,7]
del ls[2]
print(ls)

OUTPUT:
[1, 2, 7]


Deleting An All Odd Indexed Elements
ls=[1,2,3,4,5,6,7,8,9]
del ls[1::2]
print(ls)
 
OUTPUT:
[1, 3, 5, 7, 9]

Tuple Operations.:

Different types of tuples

Empty tuple:
my_tuple = ()
print(my_tuple)

Tuple having integers:
my_tuple = (1, 2, 3)
print(my_tuple)

Tuple with mixed datatypes: 
my_tuple = (1, "Hello", 3.4)
print(my_tuple)

Nested tuple:
my_tuple = ("mouse", [8, 4, 6], (1, 2, 3))
print(my_tuple)

OUTPUT:
()
(1, 2, 3)
(1, 'Hello', 3.4)
('mouse', [8, 4, 6], (1, 2, 3))

Accessing tuple elements using indexing
my_tuple = ('p','e','r','m','i','t')

print(my_tuple[0])    
print(my_tuple[5])   
print(my_tuple[6])
my_tuple[2.0]

nested tuple
n_tuple = ("mouse", [8, 4, 6], (1, 2, 3))

nested index
print(n_tuple[0][3])      
print(n_tuple[1][1])  
    
Negative indexing for accessing tuple elements

my_tuple = ('p', 'e', 'r', 'm', 'i', 't')

print(my_tuple[-1])

print(my_tuple[-6])

OUTPUT:
p
t
s
4
t
p
Slicing
Accessing tuple elements using slicing
my_tuple = ('p','r','o','g','r','a','m','i','z')

# elements 2nd to 4th

print(my_tuple[1:4])

# elements beginning to 2nd

print(my_tuple[:-7])

# elements 8th to end

print(my_tuple[7:])


# elements beginning to end

print(my_tuple[:])

OUTPUT:
('r', 'o', 'g')
('p', 'r')
('i', 'z')
('p', 'r', 'o', 'g', 'r', 'a', 'm', 'i', 'z')

# Changing tuple values
my_tuple = (4, 2, 3, [6, 5])

 TypeError: 'tuple' object does not support item assignment
my_tuple[1] = 9

However, item of mutable element can be changed
my_tuple[3][0] = 9    # Output: (4, 2, 3, [9, 5])
print(my_tuple)

Tuples can be reassigned
my_tuple = ('p', 'r', 'o', 'g', 'r', 'a', 'm', 'i', 'z')

print(my_tuple)

OUTPUT:

(4, 2, 3, [9, 5])
('p', 'r', 'o', 'g', 'r', 'a', 'm', 'i', 'z')

Concatenation
print((1, 2, 3) + (4, 5, 6))

Repeat
print(("Repeat",) * 3)

OUTPUT:
(1, 2, 3, 4, 5, 6)
('Repeat', 'Repeat', 'Repeat')



Deleting tuples
my_tuple = ('p', 'r', 'o', 'g', 'r', 'a', 'm', 'i', 'z')

# can't delete items
# TypeError: 'tuple' object doesn't support item deletion
# del my_tuple[3]

# Can delete an entire tuple
del my_tuple

# NameError: name 'my_tuple' is not defined
print(my_tuple)


OUTPUT:
NameError     Traceback (most recent call last)
<ipython-input-50-6d502a6648b0> in <module>
     10 
     11 # NameError: name 'my_tuple' is not defined
---> 12 print(my_tuple)

NameError: name 'my_tuple' is not defined


 Membership test in tuple
my_tuple = ('a', 'p', 'p', 'l', 'e',)

# In operation
print('a' in my_tuple)
print('b' in my_tuple)

# Not in operation
print('g' not in my_tuple)


OUTPUT:
True
False
True



# Using a for loop to iterate through a tuple
for name in ('John', 'Kate'):
    print("Hello", name)

OUTPUT:
Hello John
Hello Kate
Dictionary Operations.
Creating Dictionary.

# empty dictionary
my_dict = {}

# dictionary with integer keys
my_dict = {1: 'apple', 2: 'ball'}

# dictionary with mixed keys
my_dict = {'name': 'John', 1: [2, 4, 3]}

# using dict()
my_dict = dict({1:'apple', 2:'ball'})

# from sequence having each item as a pair
my_dict = dict([(1,'apple'), (2,'ball')])

# get vs [] for retrieving elements
my_dict = {'name': 'Jack', 'age': 26}

# Output: Jack
print(my_dict['name'])

# Output: 26
print(my_dict.get('age'))

# Trying to access keys which doesn't exist throws error
# Output None
print(my_dict.get('address'))

# KeyError
print(my_dict['address'])
 
OUTPUT:
Jack
26
None
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
<ipython-input-9-2ec6dc01caba> in <module>
     13 
     14 # KeyError
---> 15 print(my_dict['address'])

KeyError: 'address'

Changing and adding Dictionary Elements

my_dict = {'name': 'Jack', 'age': 26}

# update value
my_dict['age'] = 27

#Output: {'age': 27, 'name': 'Jack'}
print(my_dict)

# add item
my_dict['address'] = 'Downtown'

# Output: {'address': 'Downtown', 'age': 27, 'name': 'Jack'}
print(my_dict)

OUTPUT
{'name': 'Jack', 'age': 27}
{'name': 'Jack', 'age': 27, 'address': 'Downtown'}
________________________________________

# Removing elements from a dictionary
# create a dictionary
squares = {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
# remove a particular item, returns its value
print(squares.pop(4))

print(squares)
# remove an arbitrary item, return (key,value)
print(squares.popitem())
print(squares)
# remove all items
squares.clear()
print(squares)
# delete the dictionary itself
del squares
# Throws Error
print(squares)

OUTPUT:
16
{1: 1, 2: 4, 3: 9, 5: 25}
(5, 25)
{1: 1, 2: 4, 3: 9}
{}

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-11-d119a0a5b684> in <module>
     28 
     29 # Throws Error
---> 30 print(squares)

NameError: name 'squares' is not defined

#Set Operations.
# Program to perform different set operations like in mathematics

# define  sets
E = {0, 2, 4, 6, 8};
N = {1, 2, 3, 4, 5};

# set union
print("Union of E and N is",E | N)

# set intersection
print("Intersection of E and N is",E & N)

# set difference
print("Difference of E and N is",E - N)

# set symmetric difference
print("Symmetric difference of E and N is",E ^ N)

OUTPUT:
Union of E and N is {0, 1, 2, 3, 4, 5, 6, 8}
Intersection of E and N is {2, 4}
Difference of E and N is {0, 8, 6}
Symmetric difference of E and N is {0, 1, 3, 5, 6, 8}

#DATE:17/08/2022
#ASSIGNMENT NO:03
#TOPIC create a function and Ask the users for two inputs and ask  what is the operators
#create a function which gets two user inputs as operands and the operation to be performed on them as user input as well. and do the calculation


#CODE:

num1=int(input("enter the value of num1:"))
num2=int(input("enter the value of num2:"))
operator=input("Enter the operator:")
if operator == "+":
  print(num1 + num2)
elif operator == "-":
  print(num1 - num2)
elif operator == "*":
  print(num1 * num2)
elif operator == "/":
  print(num1/num2)
else:
  print("Invalid operator")


OUTPUT:01 when we give correct operator and correct operands
enter the value of num1:12
enter the value of num2:34
Enter the operator:+
46

OUTPUT:02 when we give correct operator and wrong operands

enter the value of num1:2
enter the value of num2:t
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-da0db4b4eadf> in <module>
      1 num1=int(input("enter the value of num1:"))
----> 2 num2=int(input("enter the value of num2:"))
      3 operator=input("Enter the operator:")
      4 if operator == "+":
      5   print(num1 + num2)

ValueError: invalid literal for int() with base 10: 't'

OUTPUT:01 when we give wrong operator and correct operands
enter the value of num1:2
enter the value of num2:4
Enter the operator:$
Invalid operator

#DATE:22/08/2022
#ASSIGNMENT NO:04.
#TOPIC: DIFFERENT FILE MODES IN PYTHON.

#The file handling plays an important role when the data needs to be stored permanently into the file. A file is a named location on disk to store related information. We can access the stored information (non-volatile) after the program termination.
The file-handling implementation is slightly lengthy or complicated in the other programming language, but it is easier and shorter in Python.
In Python, files are treated in two modes as text or binary. The file may be in the text or binary format, and each line of a file is ended with the special character.
Hence, a file operation can be done in the following order.
o	Open a file
o	Read or write - Performing operation
o	Close the file

#Opening File:
Python provides an open() function that accepts two arguments, file name and access mode in which the file is accessed. The function returns a file object which can be used to perform various operations like reading, writing, etc.

#Syntax:
        file object = open(<file-name>, <access-mode>, <buffering>)     
The files can be accessed using various modes like read, write, or append. The following are the details about the access mode to open a file.

#r: It opens the file to read-only mode. The file pointer exists at the beginning. The file is by default open in this mode if no access mode is passed.

#Example:
myfile=open("file.txt","r")
print(myfile.read())
myfile.close()

#OUTPUT:
Hi,Goodafternoon
 Hi,Goodafternoon

#w: It opens the file to write only. It overwrites the file if previously exists or creates a new one if no file exists with the same name. The file pointer exists at the beginning of the file.

#Example 1
myfile=open("file.txt","w")
myfile.write("This Is Written By User")
  
#OUTPUT 1:
23

#Example 2:
myfile=open("file.txt","w")
myfile.write("This Is Written By User")
myfile=open("file.txt","r")
print(myfile.read())
  
OUTPUT 2:
This Is Written By User

#a: It opens the file in the append mode. The file pointer exists at the end of the previously written file if exists any. It creates a new file if no file exists with the same name.

#Example:
myfile=open("file.txt","a")
myfile.write("\n This is Written By Programmer")
myfile=open("file.txt","r")
print(myfile.read())

#Output:
This Is Written By User
 This is Written By Programmer

#r+: It opens the file to read and write both. The file pointer exists at the beginning of the file.
Example:
myfile=open("file.txt","r+")
myfile.write("\n Hi,Goodafternoon")
myfile=open("file.txt","r")
print(myfile.read())

#Output:
Hi,Goodafternoon User
 This is Written By Programmer

#w+: It opens the file to write and read both. It is different from r+ in the sense that it overwrites the previous file if one exists whereas r+ doesn't overwrite the previously written file. It creates a new file if no file exists. The file pointer exists at the beginning of the file.
Example:
myfile=open("file.txt","w+")
myfile.write("\n Hi,Goodafternoon")
myfile=open("file.txt","r")
print(myfile.read())

#Output:
 Hi,Goodafternoon

#a+: It opens a file to append and read both. The file pointer remains at the end of the file if a file exists. It creates a new file if no file exists with the same name

#Output:
myfile=open("file.txt","a+")
myfile.write("\n Hi,Goodafternoon")
myfile=open("file.txt","r")
print(myfile.read())

#Output:
Hi,Goodafternoon
 Hi,Goodafternoon


#DATE:23/08/2022

#ASSIGNMENT NO:05.

#TOPIC: ADVANCE ARGUMENT PASSING IN PYTHON

#Paramarameters and Arguements
•Parameters are the variables that are defined or used inside parentheses while defining a function
•Arguments are the value passed for these parameters while calling function•

Example:rguments are the value passed for these parameters while calling function
def name(name): # name is the parameter
    print("my name is :", name)
name("anoop") # 'anoop' is the argument

Output:
my name is : anoop

#Positional and keyword arguments
We can pass arguments as positional or keyword arguments. Some benefits of keyword arguments can be: - We can call arguments by their names to make it more clear what they represent - We can rearrange arguments in a way that makes them most readablemeters while calling function

#Example: Positional Arguement
def student(name,branch,marks):
  print("Student name:",name,"Branch:",branch,"Obtained Marks:", marks)
student("Anil","Computer Science",98)  

#Output:
Student name: Anil Branch: Computer Science Obtained Marks: 98defin

#Example:  
def Employee(name,id,Company):
print("Employee name:",name,"Employee id:",id,"currently working in:",Company)
Employee(Company="TCS",name="Arun",id="23456")  
Employee("Anil","202567",Company="IBM") 
ese parameters while calling function

#Default arguments
Functions can have default arguments with a predefined value. This argument can be left out and the default value is then passed to the function, or the argument 
can be used with a different value.Note that default arguments must be defined as the last parameters in a function.nside parentheses while defining 

#Example:

def Student(marks,name="Abhi", Branch="Computer Science"):
  print("Student name is",name ,"I belongs from",Branch,"I obtained",marks,"marks")
Student(98)
Student(98,"akash","Information Technology") 

#Output:
Student name is Abhi I belongs from Computer Science I obtained 98 marks
Student name is akash I belongs from Information Technology I obtained 98 markse passed for these parameters while calling function
